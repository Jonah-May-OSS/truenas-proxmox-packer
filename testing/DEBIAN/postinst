#!/bin/sh
# TrueNAS-Proxmox post-install script
set -eu

_DEBUG=${_DEBUG:-on}

# 1) Detect Proxmox version
if PVE_VERSION=$(dpkg-query --showformat='${Version}' --show pve-manager 2>/dev/null); then :; else PVE_VERSION="unknown"; fi
MAJOR_VER=${PVE_VERSION%%.*}
[ "$_DEBUG" = "on" ] && echo "Proxmox Version: $PVE_VERSION (Major: $MAJOR_VER)"

# 2) Determine library path
case "$MAJOR_VER" in
  7) LIB_PATH="/usr/share/pve-7" ;;
  *) LIB_PATH="/usr/share" ;;
esac

# 3) Define file paths
PVEMANAGER_FILEPATH="$LIB_PATH/pve-manager/js/pvemanagerlib.js"
ZFSPLUGIN_FILEPATH="$LIB_PATH/perl5/PVE/Storage/ZFSPlugin.pm"
TRUENAS_PLUGIN_FILEPATH="$LIB_PATH/perl5/PVE/Storage/LunCmd/TrueNAS.pm"

echo "Running TrueNAS-Proxmox post-install..."

# 4) Backup originals
STAMP="$(date +%F-%H%M%S)"
PVEV="${PVE_VERSION:-unknown}"
BACKUP_DIR="/var/lib/truenas-proxmox/backups/${PVEV}-${STAMP}"
mkdir -p "$BACKUP_DIR"

backup() {
  local src="$1"
  [ -f "$src" ] || return 0
  local name; name="$(basename "$src")"
  cp -a "$src" "$BACKUP_DIR/$name"
  echo " - backed up $src -> $BACKUP_DIR/$name"
}

backup "$PVEMANAGER_FILEPATH"
backup "$ZFSPLUGIN_FILEPATH"

# 5) Apply GUI tweaks via sed

## 5.1 pvemanagerlib.js
if [ -f "$PVEMANAGER_FILEPATH" ]; then
  echo "Applying TrueNAS GUI sed tweaks to pvemanagerlib.js..."
  sed -i \
    -e "/\['comstar', 'Comstar'\]/a \\
        ['truenas', 'TrueNAS']," \
    "$PVEMANAGER_FILEPATH"

  sed -i \
    -e "/isComstar: *true,/a \\
            isTrueNAS: false,\\
            isLIO: false," \
    "$PVEMANAGER_FILEPATH"

  sed -i \
    -e "/vm.set('isComstar',/a \\
            vm.set('isTrueNAS', newVal === 'truenas');" \
    "$PVEMANAGER_FILEPATH"

  sed -i \
    -e "s/vm\\.set('hasWriteCacheOption'.*/vm.set('hasWriteCacheOption', newVal === 'comstar' || newVal === 'truenas' || newVal === 'istgt');/" \
    "$PVEMANAGER_FILEPATH"
else
  echo "WARNING: $PVEMANAGER_FILEPATH not found, skipping GUI sed tweaks."
fi

## 5.2 ZFSPlugin.pm (works on PVE 8.x and 9.x)
if [ -f "$ZFSPLUGIN_FILEPATH" ]; then
  echo "Applying TrueNAS patch to ZFSPlugin.pm…"

  # backup
  cp -a "$ZFSPLUGIN_FILEPATH" "${ZFSPLUGIN_FILEPATH}.bak.$(date +%F-%H%M%S)"

  # 1) import TrueNAS provider (idempotent)
  perl -0777 -i -pe 's/(use PVE::Storage::LunCmd::Comstar;)/$1\nuse PVE::Storage::LunCmd::TrueNAS;/ unless /LunCmd::TrueNAS;/' "$ZFSPLUGIN_FILEPATH"

  # 2) add list_extent capability (idempotent)
  perl -0777 -i -pe 's/(list_view\s*=>\s*1,)/$1\n    list_extent => 1,/ unless /list_extent\s*=>\s*1/' "$ZFSPLUGIN_FILEPATH"

  # 3) add TrueNAS branch to zfs_get_base dispatcher
  #    Captures optional ($scfg) so it works on 8.x (no arg) and 9.x (with $scfg)
  perl -0777 -i -pe \
  "s|(return\\s+PVE::Storage::LunCmd::Comstar::get_base)(\\(\\\$scfg\\))?;|\\\$&\n    } elsif (\\\$scfg->{iscsiprovider} eq 'truenas') {\n        return PVE::Storage::LunCmd::TrueNAS::get_base\\\$2;|s unless /TrueNAS::get_base/" \
  "$ZFSPLUGIN_FILEPATH"

  # 4) add TrueNAS branch to run_lun_command dispatcher
  perl -0777 -i -pe \
  "s|(\\\$msg\\s*=\\s*PVE::Storage::LunCmd::Comstar::run_lun_command\\(\\\$scfg,\\s*\\\$timeout,\\s*\\\$method,\\s*\\\@params\\);\\s*)|\\\$1        } elsif (\\\$scfg->{iscsiprovider} eq 'truenas') {\n            \\\$msg = PVE::Storage::LunCmd::TrueNAS::run_lun_command(\\\$scfg, \\\$timeout, \\\$method, \\\@params);\n|s unless /TrueNAS::run_lun_command/" \
  "$ZFSPLUGIN_FILEPATH"

  # 5) include 'truenas' in the error text (cosmetic)
  perl -0777 -i -pe "s/Available \\[comstar, *istgt, *iet, *LIO\\]/Available [comstar, truenas, istgt, iet, LIO]/g" "$ZFSPLUGIN_FILEPATH"

  # 6) syntax check; stop on error
  perl -c "$ZFSPLUGIN_FILEPATH" || { echo "ERROR: ZFSPlugin.pm syntax error"; exit 1; }
else
  echo "WARNING: $ZFSPLUGIN_FILEPATH not found, skipping ZFSPlugin.pm tweaks."
fi

## 5.3 ZFSPlugin.pm — WWID/Multipath enhancement (PVE 8 safe, harmless on PVE 9 libiscsi)
if [ -f "$ZFSPLUGIN_FILEPATH" ]; then
  echo "Applying WWID/Multipath enhancement to ZFSPlugin.pm…"

  # backup
  cp -a "$ZFSPLUGIN_FILEPATH" "${ZFSPLUGIN_FILEPATH}.bak.$(date +%F-%H%M%S)"

  # (A) add helper only if missing
  perl -0777 -i -pe '
    unless (/sub\s+zfs_get_wwid_number\s*\(/) {
      s|^1;\s*$|sub zfs_get_wwid_number {\n  my ($class,$scfg,$guid) = @_;\n  die \"could not find lun_number for guid $guid\" unless $guid;\n  return $class->zfs_request($scfg, undef, \"list_extent\", $guid);\n}\n\n1;\n|m;
    }' "$ZFSPLUGIN_FILEPATH"

  # (B) inject multipath resolver after the first "my $path = ..." — but only once
  perl -0777 -i -pe '
    unless (/Multipath enhancement\b/) {
      s|(my\s+\$path\s*=\s*[^;]+;)|$1\n    # Multipath enhancement (optional; only meaningful when using kernel block devices)\n    eval {\n      my $wwid = $class->zfs_get_wwid_number($scfg, $guid);\n      if ($wwid =~ /^([\\-\\@\\w\\.]+)$/) { $wwid = $1 } else { die \"Bad data in \\x27$wwid\\x27\" }\n      my $wwid_end = substr $wwid, 16; # match tail in multipath -ll output\n      my $line = `/usr/sbin/multipath -ll | grep \"$wwid_end\"`;\n      my ($mapper_device) = split(/\\s+/, $line);\n      if ($mapper_device && -b \"/dev/mapper/$mapper_device\") {\n        $path = \"/dev/mapper/$mapper_device\";\n      }\n    };\n|s;
    }' "$ZFSPLUGIN_FILEPATH"

  # syntax check
  perl -c "$ZFSPLUGIN_FILEPATH" || { echo "ERROR: ZFSPlugin.pm syntax error"; exit 1; }
else
  echo "WARNING: $ZFSPLUGIN_FILEPATH not found, skipping WWID/Multipath."
fi

# 6) Reload services
systemctl reload-or-restart pvedaemon.service    || true
systemctl reload-or-restart pveproxy.service     || true
systemctl reload-or-restart pvestatd.service     || true
systemctl reload-or-restart pvescheduler.service || true

echo "Installation complete."
exit 0
